DEG_control_vs_T3_all <- merge(merge, agg, by = "gene", all.x = TRUE)
DEG_control_vs_T3_all <- select(DEG_control_vs_T3_all, -GO_term)
DEG_control_vs_T3_all <- unique(DEG_control_vs_T3_all)
# Merge ref and DEG_control_vs_T2_all
final_DEG_CvsT3 <- merge(DEG_control_vs_T3_all, ref, by = "gene", all.x = TRUE)
write.csv(final_DEG_CvsT3, file = "~/Desktop/mcav_control_vs_T3_DEG_GO_all.csv")
## C vs T3
# DEGs with info about pvalues, counts
DEG_control_vs_T4 <- read.csv("~/Desktop/mcav_control_vs_T4_DEG_full.csv", header = TRUE)
colnames(DEG_control_vs_T4)[1] <- "gene"
# Merge this information
merge <- merge(DEG_control_vs_T4, GO_mcav, by = "gene", all.x = TRUE)
merge <- unique(merge)
# Because IPS used different databases to generate GO terms, there are multiple rows of the same gene name with different
# GO terms (because they were generated from different db).
agg <- aggregate(merge$GO_term, list(merge$gene), paste, collapse = ",")
colnames(agg) <- c("gene", "GO_terms")
# Merge the merge df and the agg df
DEG_control_vs_T4_all <- merge(merge, agg, by = "gene", all.x = TRUE)
DEG_control_vs_T4_all <- select(DEG_control_vs_T4_all, -GO_term)
DEG_control_vs_T4_all <- unique(DEG_control_vs_T4_all)
# Merge ref and DEG_control_vs_T2_all
final_DEG_CvsT4 <- merge(DEG_control_vs_T4_all, ref, by = "gene", all.x = TRUE)
View(DEG_control_vs_T4)
t1vst3, t2vst3
# Merge ref and DEG_control_vs_T2_all
final_DEG_CvsT4 <- merge(DEG_control_vs_T4_all, ref, by = "gene", all.x = TRUE)
write.csv(final_DEG_CvsT4, file = "~/Desktop/mcav_control_vs_T4_DEG_GO_all.csv")
View(DEG_control_vs_T4)
## T1 vs T3
# DEGs with info about pvalues, counts
DEG_T1_vs_T3 <- read.csv("~/Desktop/mcav_T1_vs_T3_DEG_full.csv", header = TRUE)
colnames(DEG_T1_vs_T3)[1] <- "gene"
# Merge this information
merge <- merge(DEG_T1_vs_T3, GO_mcav, by = "gene", all.x = TRUE)
merge <- unique(merge)
# Because IPS used different databases to generate GO terms, there are multiple rows of the same gene name with different
# GO terms (because they were generated from different db).
agg <- aggregate(merge$GO_term, list(merge$gene), paste, collapse = ",")
colnames(agg) <- c("gene", "GO_terms")
# Merge the merge df and the agg df
DEG_T1_vs_T3_all <- merge(merge, agg, by = "gene", all.x = TRUE)
DEG_T1_vs_T3_all <- select(DEG_T1_vs_T3_all, -GO_term)
DEG_T1_vs_T3_all <- unique(DEG_T1_vs_T3_all)
# Merge ref and DEG_control_vs_T2_all
final_DEG_T1vsT3 <- merge(DEG_T1_vs_T3_all, ref, by = "gene", all.x = TRUE)
View(DEG_T1_vs_T3_all)
write.csv(final_DEG_T1vsT3, file = "~/Desktop/mcav_T1_vs_T3_DEG_GO_all.csv")
## T2 vs T3
# DEGs with info about pvalues, counts
DEG_T2_vs_T3 <- read.csv("~/Desktop/mcav_T2_vs_T3_DEG_full.csv", header = TRUE)
colnames(DEG_T2_vs_T3)[1] <- "gene"
# Merge this information
merge <- merge(DEG_T2_vs_T3, GO_mcav, by = "gene", all.x = TRUE)
merge <- unique(merge)
# Because IPS used different databases to generate GO terms, there are multiple rows of the same gene name with different
# GO terms (because they were generated from different db).
agg <- aggregate(merge$GO_term, list(merge$gene), paste, collapse = ",")
colnames(agg) <- c("gene", "GO_terms")
# Merge the merge df and the agg df
DEG_T2_vs_T3_all <- merge(merge, agg, by = "gene", all.x = TRUE)
DEG_T2_vs_T3_all <- select(DEG_T2_vs_T3_all, -GO_term)
DEG_T2_vs_T3_all <- unique(DEG_T2_vs_T3_all)
# Merge ref and DEG_control_vs_T2_all
final_DEG_T2vsT3 <- merge(DEG_T2_vs_T3_all, ref, by = "gene", all.x = TRUE)
View(DEG_T2_vs_T3_all)
write.csv(final_DEG_T2vsT3, file = "~/Desktop/mcav_T2_vs_T3_DEG_GO_all.csv")
# Load gene count matrix
countdata <- read.csv("~/Desktop/PutnamLab/Repositories/SedimentStress/SedimentStress/Output/DESeq2/gene_count_pdam_NCBI_matrix.csv")
dim(countdata) # 37630
for ( col in 1:ncol(countdata)){
colnames(countdata)[col] <-  gsub("X", "", colnames(countdata)[col])
}
# Removing all gene_ids that are MSTRG - not helpful as they are novel spliced genes found by STAR. There may be some way to ID the specific genes associated with them, but not sure
countdata <- countdata[grep("LOC", countdata$gene_id), ]
countdata$gene_id <- gsub(".*L","", countdata$gene_id) # the | symbol being really annoying in subsetting, so removing everything up to L, then will add L back to gene_id
countdata$gene_id <- paste0("L", countdata$gene_id)
rownames(countdata) <- countdata$gene_id
# functional annotation file
annot <- read.csv("~/Desktop/GFFs/GCF_003704095.1_ASM370409v1_genomic.gff",header = FALSE, sep="\t", skip=6)
colnames(annot) <- c("scaffold", "Gene.Predict", "id", "gene.start","gene.stop", "pos1", "pos2","pos3", "attr")
# annot$gene <- annot$attr
annot <- annot[!grepl("##", annot$scaffold),]
annot$gene_id <- regmatches(annot$attr, gregexpr("(?<=gene=).*", annot$attr, perl = TRUE)) #removing everything in Symbol col up to LOC
annot$gene_id <-gsub(";.*", "", annot$gene_id)
annot <- annot[!grepl("character", annot$gene_id),]
metadata_pdam<- read.csv("~/Desktop/PutnamLab/Repositories/SedimentStress/SedimentStress/Data/metadata_pdam_raw_filtered.csv")
metadata_pdam <- na.omit(metadata_pdam)
metadata_pdam$SampleID <- gsub("X", "", metadata_pdam$SampleID)
rownames(metadata_pdam) <- metadata_pdam$SampleID
# Subset count data for only mcap samples based on SampleID and make sure rows of metadata = cols of count data
pdam_ID <- metadata_pdam$SampleID
count_pdam <- select(countdata, all_of(pdam_ID))
all(rownames(metadata_pdam) %in% colnames(count_pdam)) # must come out TRUE
# Filter reads by proportion of samples containing cutoff value
filt <- filterfun(pOverA(0.85, 5)) # set filter values for P over A; I used 0.85 and 5
tfil <- genefilter(count_pdam, filt) # create filter for counts data
keep <- count_pdam[tfil,] # identify genes to keep based on filter
gn.keep <- rownames(keep)
pdam_counts_filt <- as.matrix(count_pdam[which(rownames(count_pdam) %in% gn.keep),])
storage.mode(pdam_counts_filt) <- "integer" # stores count data as integer
# Checking to make sure rownames in metadata == colnames in counts data
all(rownames(metadata_pdam) %in% colnames(pdam_counts_filt)) # must come out TRUE
# Set Treatment as a factor
metadata_pdam$Treatment <- factor(metadata_pdam$Treatment, levels = c("control", "mid", "high"))
data <- DESeqDataSetFromMatrix(countData = pdam_counts_filt, colData = metadata_pdam, design = ~ Treatment)
# Expression visualization
# First we are going to log-transform the data using a variance stabilizing transforamtion (vst). This is only for visualization purposes.
# Essentially, this is roughly similar to putting the data on the log2 scale. It will deal with the sampling variability of low counts by calculating within-group variability (if blind=FALSE).
# Importantly, it does not use the design to remove variation in the data, and so can be used to examine if there may be any variability do to technical factors such as extraction batch effects.
# To do this we first need to calculate the size factors of our samples. This is a rough estimate of how many reads each sample contains compared to the others.
# In order to use VST (the faster log2 transforming process) to log-transform our data, the size factors need to be less than 4. Otherwise, there could be artefacts in our results.
SF.data <- estimateSizeFactors(data) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 to use vst
SF.data
print(sizeFactors(SF.data)) #view size factors
# Differential gene expression analysis
DEG.int <- DESeq(data) # run differential expression test by treatment (?) using wald test
# estimating size factors
# estimating dispersions
# gene-wise dispersion estimates
# mean-dispersion relationship
# final dispersion estimates
# fitting model and testing
DEG.int.res <- results(DEG.int) # save DE results ; why does it say 'Wald test p-value: Treatment Treatment4 vs control' for DEG.int.res? Is it only looking at treatment 4 and control? In DESeq object created above, it says that design is Treatment
resultsNames(DEG.int) # view DE results
# Compare C and mid
DEG_control_vs_mid <- results(DEG.int, contrast = c("Treatment", "control", "mid"))
DEG_control_vs_mid
DEG_control_vs_mid <- as.data.frame(DEG_control_vs_mid)
# Compare C and mid
DEG_control_vs_mid <- results(DEG.int, contrast = c("Treatment", "control", "mid"))
DEG_control_vs_mid
DEG_control_vs_mid <- as.data.frame(DEG_control_vs_mid) # make full results into a df
DEG_control_vs_mid["Treatment_Compare"] <- "CvsMid" # add treatment comparison col
write.csv(DEG_control_vs_mid, file = "~/Desktop/pdam_control_vs_mid_all_genes.csv") # maybe include gene counts too?
DEG_control_vs_mid.sig.num <- sum(DEG_control_vs_mid$padj <0.05, na.rm = T) # identify # of significant pvalues with 10%FDR (padj<0.1) -  jk using 0.05
DEG_control_vs_mid.sig.num
# 317 DEGs
DEG_control_vs_mid.sig <- subset(DEG_control_vs_mid, padj <0.05) # identify and subset significant pvalues
DEG_control_vs_mid.sig["Treatment_Compare"] <- "CvsMid" # adding treatment comparison column
DEG_control_vs_mid.sig.list <- data[which(rownames(data) %in% rownames(DEG_control_vs_mid.sig)),] # subset list of significant genes from original count data
DEG_control_vs_mid.sig.list <- as.data.frame(counts(DEG_control_vs_mid.sig.list)) # make list of sig gene counts into a df
DEG_control_vs_mid.sig.list_full <- cbind(DEG_control_vs_mid.sig, DEG_control_vs_mid.sig.list) # bind results with gene counts for DEGs
write.csv(DEG_control_vs_mid.sig.list_full, file = "~/Desktop/pdam_control_vs_mid_DEG_full.csv") # write out csv
DEG_control_vs_mid.vst.sig <- varianceStabilizingTransformation(DEG_control_vs_mid.sig.list, blind = FALSE) # apply a regularized log transformation to minimize effects of small counts and normalize wrt library
# Compare C and high
DEG_control_vs_high <- results(DEG.int, contrast = c("Treatment", "control", "high"))
DEG_control_vs_high
DEG_control_vs_high <- as.data.frame(DEG_control_vs_high) # make full results into a df
DEG_control_vs_high["Treatment_Compare"] <- "CvsHigh" # add treatment comparison col
write.csv(DEG_control_vs_high, file = "~/Desktop/pdam_control_vs_high_all_genes.csv") # maybe include gene counts too?
DEG_control_vs_high.sig.num <- sum(DEG_control_vs_high$padj <0.05, na.rm = T) # identify # of significant pvalues with 10%FDR (padj<0.1) -  jk using 0.05
DEG_control_vs_high.sig.num
# 462 DEGs
DEG_control_vs_high.sig <- subset(DEG_control_vs_high, padj <0.05) # identify and subset significant pvalues
DEG_control_vs_high.sig <- subset(DEG_control_vs_high, padj <0.05) # identify and subset significant pvalues
DEG_control_vs_high.sig["Treatment_Compare"] <- "CvsHigh" # adding treatment comparison column
DEG_control_vs_high.sig.list <- data[which(rownames(data) %in% rownames(DEG_control_vs_high.sig)),] # subset list of significant genes from original count data
DEG_control_vs_high.sig.list <- as.data.frame(counts(DEG_control_vs_high.sig.list)) # make list of sig gene counts into a df
DEG_control_vs_high.sig.list_full <- cbind(DEG_control_vs_high.sig, DEG_control_vs_high.sig.list) # bind results with gene counts for DEGs
write.csv(DEG_control_vs_high.sig.list_full, file = "~/Desktop/pdam_control_vs_high_DEG_full.csv") # write out csv
DEG_control_vs_high.vst.sig <- varianceStabilizingTransformation(DEG_control_vs_high.sig.list, blind = FALSE) # apply a regularized log transformation to minimize effects of small counts and normalize wrt library
# Compare mid and high
DEG_mid_vs_high <- results(DEG.int, contrast = c("Treatment", "mid", "high"))
DEG_mid_vs_high
DEG_mid_vs_high <- as.data.frame(DEG_mid_vs_high) # make full results into a df
DEG_mid_vs_high["Treatment_Compare"] <- "MidvsHigh" # add treatment comparison col
write.csv(DEG_mid_vs_high, file = "~/Desktop/pdam_mid_vs_high_all_genes.csv") # maybe include gene counts too?
DEG_mid_vs_high.sig.num <- sum(DEG_mid_vs_high$padj <0.05, na.rm = T) # identify # of significant pvalues with 10%FDR (padj<0.1) -  jk using 0.05
DEG_mid_vs_high.sig.num
DEG_mid_vs_high <- results(DEG.int, contrast = c("Treatment", "mid", "high"))
DEG_mid_vs_high
DEG_mid_vs_high <- as.data.frame(DEG_mid_vs_high) # make full results into a df
DEG_mid_vs_high["Treatment_Compare"] <- "MidvsHigh" # add treatment comparison col
write.csv(DEG_mid_vs_high, file = "~/Desktop/pdam_mid_vs_high_all_genes.csv") # maybe include gene counts too?
DEG_mid_vs_high.sig.num <- sum(DEG_mid_vs_high$padj <0.05, na.rm = T) # identify # of significant pvalues with 10%FDR (padj<0.1) -  jk using 0.05
DEG_mid_vs_high.sig.num
# 8 DEGs
DEG_mid_vs_high.sig <- subset(DEG_mid_vs_high, padj <0.05) # identify and subset significant pvalues
DEG_mid_vs_high.sig["Treatment_Compare"] <- "MidvsHigh" # adding treatment comparison column
DEG_mid_vs_high.sig.list <- data[which(rownames(data) %in% rownames(DEG_mid_vs_high.sig)),] # subset list of significant genes from original count data
DEG_mid_vs_high.sig.list <- as.data.frame(counts(DEG_mid_vs_high.sig.list)) # make list of sig gene counts into a df
DEG_mid_vs_high.sig.list_full <- cbind(DEG_mid_vs_high.sig, DEG_mid_vs_high.sig.list) # bind results with gene counts for DEGs
write.csv(DEG_mid_vs_high.sig.list_full, file = "~/Desktop/pdam_mid_vs_high_DEG_full.csv") # write out csv
DEG_mid_vs_high.vst.sig <- varianceStabilizingTransformation(DEG_mid_vs_high.sig.list, blind = FALSE) # apply a regularized log transformation to minimize effects of small counts and normalize wrt library
##### Unique genes from intersections of DEG in CvsT1, CvsT2, CvsT3, CvsT4, T1vsT3, T2vsT3
DEGs.all <- rbind(DEG_control_vs_mid.sig.list_full,
DEG_control_vs_high.sig.list_full,
DEG_mid_vs_high.sig.list_full)
write.csv(DEGs.all, file = "~/Desktop/pdam_DEGs.all_treatment.csv")
DEGs.all$DEGs <- rownames(DEGs.all)
DEGs.all$DEGs <- rownames(DEGs.all)
DEGs.all_pdam <- DEGs.all$DEGs
DEGs.all_pdam <- unique(DEGs.all_pdam)
DEGs.all_pdam <- as.data.frame(DEGs.all_pdam) # 89 unique DEGs among treatment comparisons
View(DEGs.all_pdam)
# Obtain names of all expressed ofav genes (poverA = 0.85,5), and all differentially expressed planuala genes (p<0.05)
gcounts_filt_pdam <- read.csv("~/Desktop/PutnamLab/Repositories/SedimentStress/SedimentStress/Output/DESeq2/pdam_counts_filt.csv", header = TRUE) # read data in
# Obtain names of all expressed ofav genes (poverA = 0.85,5), and all differentially expressed planuala genes (p<0.05)
gcounts_filt_pdam <- read.csv("~/Desktop/PutnamLab/Repositories/SedimentStress/SedimentStress/Output/DESeq2/pdam_counts_filt.csv", header = TRUE) # read data in
dim(gcounts_filt_pdam) # 13881 rows x 13
for ( col in 1:ncol(gcounts_filt_pdam)){
colnames(gcounts_filt_pdam)[col] <-  gsub("X", "", colnames(gcounts_filt_pdam)[col]) # remove X in front of col names
}
colnames(gcounts_filt_pdam)[1] <-"gene_id" # make colnames a true column called gene_id
head(gcounts_filt_pdam)
length(unique(gcounts_filt_pdam$gene_id)) # 13881 total unique gene ids
DEG_pdam <- read.csv("~/Desktop/PutnamLab/Repositories/SedimentStress/SedimentStress/Output/DESeq2/pdam_unique.sig.list.csv", header = TRUE) # read in list of significant pdam genes
dim(DEG_pdam) # 549 x 13
for ( col in 1:ncol(DEG_pdam)){
colnames(DEG_pdam)[col] <-  gsub("X", "", colnames(DEG_pdam)[col]) # remove X in front of col names
}
colnames(DEG_pdam)[1] <-"gene_id" # make colnames a true column called gene_id
head(DEG_pdam)
length(unique(DEG_pdam$gene_id)) # 549 total unique gene ids
#Import merged annotated gtf file
map <- read.csv("~/Desktop/GFFs/Pdam.merged.annotated.gtf", header=FALSE, sep="\t") # read in merged annotated pdam file created with stringTie
colnames(map) <- c("scaffold", "Gene.Predict", "id", "gene.start","gene.stop", "pos1", "pos2","pos3", "attr") # name columns
map <- map[!grepl("#", map$scaffold),] # remove rows that have a # in scaffold col
map <- map[grep("LOC", map$attr), ] # select all rows that have LOC in attr col
map$gene_id <- regmatches(map$attr, gregexpr("(?<=gene_name).*", map$attr, perl = TRUE)) #removing everything in Symbol col up to LOC and making new col called gene_id
map$gene_id <- gsub(";.*", "", map$gene_id) # remove everything after ;
map$gene_id <- gsub(" ", "", map$gene_id) # remove any blank spaces
map <- subset(map, id=="transcript") # select only transcripts
map <- select(map, c(scaffold, gene.start, gene.stop, gene_id)) # keep only specified cols
map_unique <- unique(map)
dim(map_unique) # 26139 x 4
length(unique(map_unique$gene_id)) # 22734 unique geneids
ref <- read.csv("~/Desktop/GFFs/GCF_003704095.1_ASM370409v1_genomic.gff",header = FALSE, sep="\t", skip=6)
colnames(ref) <- c("scaffold", "Gene.Predict", "id", "gene.start","gene.stop", "pos1", "pos2","pos3", "attr") # name cols
ref <- ref[!grepl("##", ref$scaffold),] # remove rows that have a # in scaffold col
#ref <- subset(ref, id == "gene") # select only genes -- skipping this for now because I am having some issues with using nullp and lengths of vectors
#ref <- ref[grep("XP", ref$attr), ] # isolate XP protein name
#ref$prot <- gsub(";.*", "", ref$attr)
#ref$prot <- gsub("ID=", "", ref$prot)
#ref$prot <- gsub(".*-", "", ref$prot)
ref$gene_id <- regmatches(ref$attr, gregexpr("(?<=gene=).*", ref$attr, perl = TRUE)) #removing everything in Symbol col up to LOC and creating new col called gene_id
ref$gene_id <- gsub(";.*", "", ref$gene_id) # remove everything after ;
ref <- ref[!grepl("character", ref$gene_id),] # remove rows that have 'character' in gene_id col
ref <- select(ref, c(scaffold, gene.start, gene.stop, id, gene_id)) # select only certain cols
ref <- ref %>% mutate(ref, length = gene.stop - gene.start) # calculate gene length
dim(ref) # 484440 x 6
length(unique(ref$gene_id)) # 22799
ref <- unique(ref)
ref <- subset(ref, id == "gene") # select only genes -- maybe i do need to do this step??
dim(ref) # 21837 x 6
#ref <- unique(ref)
# Build a dataframe that links the gene IDs of expressed genes (poverA = 0.85,5), the gene ids of those genes (from the gene map), and the gene lengths (from the annotation file)
pdam_filt.map_unique <- merge(map_unique, gcounts_filt_pdam, by = "gene_id", all.x = TRUE) # merge gcounts_filt_pdam and map_unique by gene_id
dim(pdam_filt.map_unique) # should be same # of rows as gcounts_filt_pdam ?? but it is not... dim is 26139 x 16
pdam_filt.map_unique <- na.omit(pdam_filt.map_unique)
dim(pdam_filt.map_unique) # 16516 rows...still not same as gcounts_filt_pdam
length(unique(pdam_filt.map_unique$gene_id)) # so there are correct number of ids...maybe I have to remove scaffold?
pdam_filt.map_unique <- select(pdam_filt.map_unique, -scaffold)
pdam_filt.map_unique <- unique(pdam_filt.map_unique)
dim(pdam_filt.map_unique) # still the same...16516
pdam_filt.map_unique <- select(pdam_filt.map_unique, -c(gene.start, gene.stop)) # remove gene start and stop? idk trying to get number down to match gcounts_filt_pdam
pdam_filt.map_unique <- unique(pdam_filt.map_unique) # okay finally at 13881! But i will probably need gene lengths......
#Find gene positions in ref corresponding to expressed genes
pdam_filt.map_unique.ref <- merge(pdam_filt.map_unique, ref, by = "gene_id", all.x= TRUE) # merge pdam_filt.map_unique and ref by gene_idpdam_filt.map_unique.ref <- select(pdam_filt.map_unique.ref, -c(scaffold.x, gene.start.x, gene.stop.x)) # remove specified cols
pdam_filt.map_unique.ref <- select(pdam_filt.map_unique.ref, -c(scaffold, gene.start, gene.stop))
dim(pdam_filt.map_unique.ref) # 13881 x 18
#### Build GOSEQ vector
#GOseq requires a vector of all genes and all differentially expressed genes.
#Make gene vector
DEG <- filter(pdam_filt.map_unique.ref, gene_id%in%DEG_pdam$gene_id) #make vector of differentially expressed genes
dim(DEG) #should be 549 - yes
DEG <- DEG$gene_id # I believe I only need the gene ids here
DEG <- unique(DEG) # okay unique DEGs # is 549
DEG_names <- as.vector(DEG)
#non-differentially expressed genes as 0 and differentially expressed genes as 1
gene_vector=as.integer(pdam_filt.map_unique.ref$gene_id%in%DEG_names)
names(gene_vector)=unique(pdam_filt.map_unique.ref$gene_id)
length(unique(names(gene_vector))) # 13881
head(gene_vector)
#Make ID vector
ID_vector <- pdam_filt.map_unique.ref$gene_id
head(ID_vector)
ID_vector <- unique(ID_vector)
#Make length vector
length_vector <- pdam_filt.map_unique.ref$length
head(length_vector)
#Calculate Probability Weighting Function
DEG.pwf<-nullp(gene_vector, ID_vector, bias.data=length_vector) #weight vector by length of gene
annot_GO <- read.csv("~/Desktop/PutnamLab/Repositories/SedimentStress/SedimentStress/Output/GOSeq/pdam_GOterms_DEGs.csv", header=TRUE)
annot_GO <- select(annot_GO, -X)
colnames(annot_GO)[1] <-"gene_id"
annot_GO.ref <- merge(annot_GO, ref, by = "gene_id", all.x= TRUE)
annot_GO.ref <- unique(annot_GO.ref)
annot_GO.ref <- select(annot_GO.ref, c(gene_id, GO_term))
split_GO <- strsplit(as.character(annot_GO.ref$GO_term), ",")
GO.terms <- data.frame(v1 = rep.int(annot_GO.ref$gene_id, sapply(split_GO, length)), v2 = unlist(split_GO)) #list all genes with each of their GO terms in a single row
colnames(GO.terms) <- c("gene_id", "GO.ID")
# save df here to get gene names with one GO name per row. All GO terms still there, but listed individually
write.csv(GO.terms, file = "~/Desktop/pdam_GOterms_ByGene.csv")
GO.terms <- merge(pdam_filt.map_unique.ref, GO.terms, by.x = "gene_id")
dim(GO.terms) # 1072 x 19
GO.terms <- select(GO.terms, c(gene_id, GO.ID))
GO.terms$GO.ID<- as.character(GO.terms$GO.ID)
dim(GO.terms)
GO.terms[GO.terms == 0] <- "unknown"
GO.terms <- unique(GO.terms)
GO.terms$GO.ID <- replace_na(GO.terms$GO.ID, "unknown")
GO.terms$GO.ID <- as.factor(GO.terms$GO.ID)
GO.terms$gene_id <- as.factor(GO.terms$gene_id)
head(GO.terms, 10)
tail(GO.terms, 10)
### Perform GOseq
# Find enriched GO terms, "selection-unbiased testing for category enrichment amongst differentially expressed (DE) genes for RNA-seq data"
# should I include this: test.cats=c("GO:CC", "GO:BP", "GO:MF") ?
GO.wall<-goseq(DEG.pwf, ID_vector, gene2cat=GO.terms, method="Wallenius", use_genes_without_cat=TRUE)
#Calculate Probability Weighting Function
DEG.pwf<-nullp(gene_vector, ID_vector, bias.data=length_vector) #weight vector by length of gene
#Calculate Probability Weighting Function
DEG.pwf<-nullp(gene_vector, ID_vector, bias.data=length_vector) #weight vector by length of gene
### Perform GOseq
# Find enriched GO terms, "selection-unbiased testing for category enrichment amongst differentially expressed (DE) genes for RNA-seq data"
# should I include this: test.cats=c("GO:CC", "GO:BP", "GO:MF") ?
GO.wall<-goseq(DEG.pwf, ID_vector, gene2cat=GO.terms, method="Wallenius", use_genes_without_cat=TRUE)
class(GO.wall)
head(GO.wall)
tail(GO.wall)
nrow(GO.wall)
#Find only enriched GO terms that are statistically significant at cutoff - 0.05
enriched.GO.05.a<-GO.wall$category[GO.wall$over_represented_pvalue<.05]
enriched.GO.05<-data.frame(enriched.GO.05.a)
colnames(enriched.GO.05) <- c("category")
enriched.GO.05 <- merge(enriched.GO.05, GO.wall, by="category")
enriched.GO.05 <- enriched.GO.05[order(-enriched.GO.05$numDEInCat),]
enriched.GO.05$term <- as.factor(enriched.GO.05$term)
head(enriched.GO.05)
MF <- subset(enriched.GO.05, ontology=="MF")
MF <- MF[order(-MF$numDEInCat),]
CC <- subset(enriched.GO.05, ontology=="CC")
CC <- CC[order(-CC$numDEInCat),]
BP <- subset(enriched.GO.05, ontology=="BP")
BP <- BP[order(-BP$numDEInCat),]
# Combining all and ordering by pvalue
GOplot2_pvalue <- enriched.GO.05 %>% drop_na(ontology) %>% mutate(term = fct_reorder(term, over_represented_pvalue)) %>%
mutate(term = fct_reorder(term, ontology)) %>%
ggplot( aes(x=term, y=over_represented_pvalue) ) +
geom_segment( aes(x=term ,xend=term, y=0, yend=over_represented_pvalue), color="grey") +
geom_point(size=3, aes(colour = ontology)) +
geom_text(aes(label = numDEInCat), hjust = -1, vjust = 0.5, size = 3) +
coord_flip() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position="bottom"
) +
xlab("") +
ylab("p-value") +
theme_bw() + #Set background color
theme(panel.border = element_blank(), # Set border
panel.grid.major = element_blank(), #Set major gridlines
panel.grid.minor = element_blank(), #Set minor gridlines
axis.line = element_line(colour = "black"), #Set axes color
plot.background=element_blank()) #Set the plot background #set title attributes
GOplot2_pvalue
# Combining all and ordering by pvalue
GOplot2_pvalue <- enriched.GO.05 %>% drop_na(ontology) %>% mutate(term = fct_reorder(term, over_represented_pvalue)) %>%
mutate(term = fct_reorder(term, ontology)) %>%
ggplot( aes(x=term, y=over_represented_pvalue) ) +
geom_segment( aes(x=term ,xend=term, y=0, yend=over_represented_pvalue), color="grey") +
geom_point(size=3, aes(colour = ontology)) +
geom_text(aes(label = numDEInCat), hjust = -1, vjust = 0.5, size = 3) +
coord_flip() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position="bottom"
) +
xlab("") +
ylab("p-value") +
theme_bw() + #Set background color
theme(panel.border = element_blank(), # Set border
panel.grid.major = element_blank(), #Set major gridlines
panel.grid.minor = element_blank(), #Set minor gridlines
axis.line = element_line(colour = "black"), #Set axes color
plot.background=element_blank()) #Set the plot background #set title attributes
GOplot2_pvalue
# Combining all into one plot
GOplot2 <- enriched.GO.05 %>% drop_na(ontology) %>% mutate(term = fct_reorder(term, numDEInCat)) %>%
mutate(term = fct_reorder(term, ontology)) %>%
ggplot( aes(x=term, y=numDEInCat) ) +
geom_segment( aes(x=term ,xend=term, y=0, yend=numDEInCat), color="grey") +
geom_point(size=3, aes(colour = ontology)) +
#geom_text(aes(label = over_represented_pvalue), hjust = 0, vjust = 0, size = 1) +
coord_flip() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position="bottom"
) +
xlab("") +
ylab("") +
theme_bw() + #Set background color
theme(panel.border = element_blank(), # Set border
panel.grid.major = element_blank(), #Set major gridlines
panel.grid.minor = element_blank(), #Set minor gridlines
axis.line = element_line(colour = "black"), #Set axes color
plot.background=element_blank()) #Set the plot background #set title attributes
GOplot2
dev.off()
# Combining all and ordering by pvalue
GOplot2_pvalue <- enriched.GO.05 %>% drop_na(ontology) %>% mutate(term = fct_reorder(term, over_represented_pvalue)) %>%
mutate(term = fct_reorder(term, ontology)) %>%
ggplot( aes(x=term, y=over_represented_pvalue) ) +
geom_segment( aes(x=term ,xend=term, y=0, yend=over_represented_pvalue), color="grey") +
geom_point(size=3, aes(colour = ontology)) +
geom_text(aes(label = numDEInCat), hjust = -1, vjust = 0.5, size = 3) +
coord_flip() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position="bottom"
) +
xlab("") +
ylab("p-value") +
theme_bw() + #Set background color
theme(panel.border = element_blank(), # Set border
panel.grid.major = element_blank(), #Set major gridlines
panel.grid.minor = element_blank(), #Set minor gridlines
axis.line = element_line(colour = "black"), #Set axes color
plot.background=element_blank()) #Set the plot background #set title attributes
GOplot2_pvalue
# Combining all and ordering by pvalue
GOplot2_pvalue <- BP %>% drop_na(ontology) %>% mutate(term = fct_reorder(term, over_represented_pvalue)) %>%
mutate(term = fct_reorder(term, ontology)) %>%
ggplot( aes(x=term, y=over_represented_pvalue) ) +
geom_segment( aes(x=term ,xend=term, y=0, yend=over_represented_pvalue), color="grey") +
geom_point(size=3, aes(colour = ontology)) +
geom_text(aes(label = numDEInCat), hjust = -1, vjust = 0.5, size = 3) +
coord_flip() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position="bottom"
) +
xlab("") +
ylab("p-value") +
theme_bw() + #Set background color
theme(panel.border = element_blank(), # Set border
panel.grid.major = element_blank(), #Set major gridlines
panel.grid.minor = element_blank(), #Set minor gridlines
axis.line = element_line(colour = "black"), #Set axes color
plot.background=element_blank()) #Set the plot background #set title attributes
GOplot2_pvalue
GOplot2_pvalue
ggsave("~/Desktop/pdam_BP_GOplot2_pvalue_05.pdf", GOplot2_pvalue, width = 28, height = 32, units = c("in"))
# Combining all and ordering by pvalue -- CC
GOplot2_pvalue <- CC %>% drop_na(ontology) %>% mutate(term = fct_reorder(term, over_represented_pvalue)) %>%
mutate(term = fct_reorder(term, ontology)) %>%
ggplot( aes(x=term, y=over_represented_pvalue) ) +
geom_segment( aes(x=term ,xend=term, y=0, yend=over_represented_pvalue), color="grey") +
geom_point(size=3, aes(colour = ontology)) +
geom_text(aes(label = numDEInCat), hjust = -1, vjust = 0.5, size = 3) +
coord_flip() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position="bottom"
) +
xlab("") +
ylab("p-value") +
theme_bw() + #Set background color
theme(panel.border = element_blank(), # Set border
panel.grid.major = element_blank(), #Set major gridlines
panel.grid.minor = element_blank(), #Set minor gridlines
axis.line = element_line(colour = "black"), #Set axes color
plot.background=element_blank()) #Set the plot background #set title attributes
GOplot2_pvalue
ggsave("~/Desktop/pdam_CC_GOplot2_pvalue_05.pdf", GOplot2_pvalue, width = 28, height = 32, units = c("in"))
# Combining all and ordering by pvalue -- MF
GOplot2_pvalue <- MF %>% drop_na(ontology) %>% mutate(term = fct_reorder(term, over_represented_pvalue)) %>%
mutate(term = fct_reorder(term, ontology)) %>%
ggplot( aes(x=term, y=over_represented_pvalue) ) +
geom_segment( aes(x=term ,xend=term, y=0, yend=over_represented_pvalue), color="grey") +
geom_point(size=3, aes(colour = ontology)) +
geom_text(aes(label = numDEInCat), hjust = -1, vjust = 0.5, size = 3) +
coord_flip() +
theme(
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_blank(),
legend.position="bottom"
) +
xlab("") +
ylab("p-value") +
theme_bw() + #Set background color
theme(panel.border = element_blank(), # Set border
panel.grid.major = element_blank(), #Set major gridlines
panel.grid.minor = element_blank(), #Set minor gridlines
axis.line = element_line(colour = "black"), #Set axes color
plot.background=element_blank()) #Set the plot background #set title attributes
GOplot2_pvalue
ggsave("~/Desktop/pdam_MF_GOplot2_pvalue_05.pdf", GOplot2_pvalue, width = 28, height = 32, units = c("in"))
## C vs Mid
# DEGs with info about pvalues, counts
DEG_control_vs_mid <- read.csv("~/Desktop/pdam_control_vs_mid_DEG_full.csv", header = TRUE)
colnames(DEG_control_vs_T1)[1] <- "gene"
colnames(DEG_control_vs_mid)[1] <- "gene"
View(DEG_control_vs_mid)
# GO terms with gene names
GO_pdam <- read.csv("~/Desktop/PutnamLab/Repositories/SedimentStress/SedimentStress/Output/GOSeq/pdam_GOterms.csv", header = TRUE)
GO_pdam <- select(GO_pdam, -c(X, Predict))
View(GO_pdam)
GO_pdam <- select(GO_pdam, -c(X, Predict))
GO_pdam <- unique(GO_pdam)
colnames(GO_pdam)[1] <- "gene"
# Merge this information
merge <- merge(DEG_control_vs_mid, GO_pdam, by = "gene", all.x = TRUE)
View(merge)
